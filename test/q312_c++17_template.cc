// compile with - C++17
//
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// -v 		    verbose show commands issued by compiler / linker
// -Wall 	    show c++ related warnnings
// -Weff++ 	  warning generated by code that breaks coding advice in Effective C++ - S.Meyers
// -g  		    include debugger information
// -std=c++17 __cplusplus=201703 => C++ Standard=C++17

// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thread, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


//#include<cassert>
//#include<iostream>
//using namespace std;
//
//#include"interface_demo.h"
//
//
//unsigned int read_io_pin_00 (void) {
//	volatile int port_pins = 0x50;		// simulate a port read
//										
//	return port_pins & 0x01;	
//}
//
//// call_stack(5) to create a 5 frame call stack
//// set BP on new_depths = 0xFF0
//int call_stack(int deep, int how_deep = 0){
//	
//	volatile long int new_depths = 0xFF << how_deep;
//	
//	cout << new_depths << endl;
//	
//	if (how_deep <= deep)
//		call_stack(deep, how_deep+1);
//	
//	return 0; 
//}
#include <string>
#include<iostream>
using namespace std;
   //std::string fileInfo = std::string("File: ") + __FILE__;
   //cout << fileInfo;

// q312_b.cc
// C++17 compiling
// from
// https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/
// Compiles A OK!

#include <array>
//#include <iostream>
#include <string_view>
#include <tuple>
#include <type_traits>

namespace a::b::c
{
    inline constexpr std::string_view str{ "hello" };
}

template <class... T>
std::tuple<std::size_t, std::common_type_t<T...>> sum(T... args)
{
    return { sizeof...(T), (args + ...) };
}

int main()
{
    auto [iNumbers, iSum]{ sum(1, 2, 3) };
    std::cout << a::b::c::str << ' ' << iNumbers << ' ' << iSum << '\n';

    std::array arr{ 1, 2, 3 };

    std::cout << std::size(arr) << '\n';

    return 0;
}

//// struct vs class
//  The only difference between a struct and class in C++ is the default accessibility
//  of member variables and methods. In a struct they are public; in a class they are private
//  
//  - - - SO
//  class B {
//  public:
//      int x = 0;
//  };
//  
//  - - - SAME AS
//  struct B {
//      int x = 0;
//  };

//// difference private and public inheritance
// protected inheritance makes the public and protected members of the base class protected in the derived class.
// private inheritance makes the public and protected members of the base class private in the derived class.
//   
// protected vs private
// private members are only accessible within the class defining them.
// protected members are accessible in the class that defines them and in classes that inherit from that class.

// using virtual keyword to avoid problems from multiple (diamond) inheritance - same class inherited through two paths
// https://www.geeksforgeeks.org/multiple-inheritance-in-c/


// COMPILE - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// NOTE cout << __cplusplus << endl;    // 199711 = C++98   WTF!? <<<
//
// https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/
// setting compiler language version
//
// For GCC/G++ users
// 
// For GCC/G++, you can pass compiler flags -std=c++11, -std=c++14, -std=c++17, or -std=c++20
// to enable C++11/14/17/20 support respectively.
// 
// If you have GCC 8 or 9, youâ€™ll need to use -std=c++2a for C++20 support instead.

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// 201703   = C++17
// still gives the same errors!

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// g++ -v -Wall -Weffc++ test_c++.cc -o test_c++
//
//test_c++.cc:94:11: warning: in-class initialization of non-static data member is a C++11 extension [-Wc++11-extensions]
//    int x = 0;
//          ^
//test_c++.cc:105:5: error: cannot cast 'C' to its private base class 'B'
//    c.x = 3;
//    ^
//test_c++.cc:97:21: note: implicitly declared private here
//class C : public A, B {};
//                    ^
//test_c++.cc:105:7: error: 'x' is a private member of 'B'
//    c.x = 3;
//      ^
//test_c++.cc:97:21: note: constrained by implicitly private inheritance here
//class C : public A, B {};
//                    ^
//test_c++.cc:94:9: note: member is declared here
//    int x = 0;
//        ^
//test_c++.cc:110:18: error: cannot cast 'C' to its private base class 'B'
//    std::cout << c.x << d.x;
//                 ^
//test_c++.cc:97:21: note: implicitly declared private here
//class C : public A, B {};
//                    ^
//test_c++.cc:110:20: error: 'x' is a private member of 'B'
//    std::cout << c.x << d.x;
//                   ^
//test_c++.cc:97:21: note: constrained by implicitly private inheritance here
//class C : public A, B {};
//                    ^
//test_c++.cc:94:9: note: member is declared here
//    int x = 0;
//        ^
//1 warning and 4 errors generated.


