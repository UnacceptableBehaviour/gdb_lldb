// compile with - C++17
//
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// -v 		    verbose show commands issued by compiler / linker
// -Wall 	    show c++ related warnnings
// -Weff++ 	  warning generated by code that breaks coding advice in Effective C++ - S.Meyers   
// -g  		    include debugger information
// -std=c++17 __cplusplus=201703 => C++ Standard=C++17

// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thread, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


//#include<cassert>
//#include<iostream>
//using namespace std;
//
//#include"interface_demo.h"
//
//
//unsigned int read_io_pin_00 (void) {
//	volatile int port_pins = 0x50;		// simulate a port read
//										
//	return port_pins & 0x01;	
//}
//
//// call_stack(5) to create a 5 frame call stack
//// set BP on new_depths = 0xFF0
//int call_stack(int deep, int how_deep = 0){
//	
//	volatile long int new_depths = 0xFF << how_deep;
//	
//	cout << new_depths << endl;
//	
//	if (how_deep <= deep)
//		call_stack(deep, how_deep+1);
//	
//	return 0; 
//}

// std::cout << a << b << '\n';
// std::cout << n << ", " << n << ", " << n << ", " << n << ", " << " \n";
#include <iostream>
//#include <string>
//#include <algorithm>  // std::find, std::for_each

void p(int v, std::string msg=""){
    std::cout << msg << ": " << v << " \n";  
}

//#include <vector>
//void pv(std::vector<int> v, std::string msg=""){
//    std::cout << msg << ": " << "v = { ";
//    for (int n : v) {
//        std::cout << n << " ";
//    }
//    std::cout << "}; \n";  
//}





// https://cppquiz.org/
// q295.cc

char a[2] = "0";            // "0" = '0''/0' = decimal 48 00
                            // heap allocated r/w memory
                            
  
// https://stackoverflow.com/questions/7903551/when-to-use-const-char-and-when-to-use-const-char  
//const char* a = "0";        // "0" = '0''/0' = decimal 48 00
//                            // allocated to read only memory - 
//                      // same as above 115 but deprecated C++03
//char* a = "0";        // "0" = '0''/0' = decimal 48 00
                            
                            
struct a_string {
   a_string() { *a='1'; std::cout << "ctor\n";}   // a[0] = '1' = '1''/0' = decimal 49 00
   ~a_string() { *a='0'; std::cout << "dtor\n"; }  // a[0] = '0' = '0''/0' = decimal 48 00
   const char* c_str() const { return a; }  // return a = pointer to address of a[]
   // return type const char*
   // c_str() const, means implicit "this" pointer is const-qualified! - REF 1: f() const
   
};

void print(const char* s) { std::cout << s << "\n"; }   // 
a_string make_string() { return a_string{}; }
  // a_string{}; call ctor
  // () uses value initialization if the parentheses are empty, or direct initialization if non-empty.
  // {} uses list initialization, which implies value initialization if the braces are empty,
  //    or aggregate initialization if the initialized object is an aggregate.

int main() {
   std::cout << "a_string s1 = make_string();" << "\n";
   a_string s1 = make_string(); // create obj s1 type a_string - sets a[0] = '1', a[] = '1''/0' = decimal 49 00
   print(s1.c_str());           // print 1

   std::cout << "const char* s2 = make_string().c_str();" << "\n";
   const char* s2 = make_string().c_str();  // create temp object  - sets a[0] = '1', a[] = '1''/0'
                                            // s2 = temp.c_str() = a  -  i think temp goes out of scope at end of c_str{ scope }<--
                                            // ; temp destructed   - sets a[0] = '0', a[] = '0''/0'
   print(s2);                   // print 0

   std::cout << "print(make_string().c_str());" << "\n";
   print(make_string().c_str());// print 1  - temp still in scope until ent of print(){ scope }<--
}

// // o/p
// a_string s1 = make_string();
// ctor
// 1
// const char* s2 = make_string().c_str();
// ctor
// dtor
// 0
// print(make_string().c_str());
// ctor
// 1
// dtor
// dtor                <- from first a_string s1 = make_string();
// 
// This demonstrates the lifetime of temporary objects, and a potential pitfall, especially when refactoring.
// 
// Let's look at main() one line at a time:
// 
// a_string s1 = make_string(); creates an a_string, and a is set to 1.
// This object is not destroyed (and a set back to 0 again) until at the very end of main(), after we're done
// printing.
// 
// Then print(s1.c_str()); is called, printing the value of a, which is now 1.
// 
// Next, we do const char* s2 = make_string().c_str();. The temporary a_string created by the call to make_string
// sets a to 1, but then back to 0 again when it is destroyed. By the time we get to print(s2);, it prints 0.
// Had this been a real std::string, print(s2); would cause undefined behavior since s2 is an invalid pointer!
// 
// In print(make_string().c_str()); the temporary object is instead destroyed after the call to print returns,
// so 1 is printed.
// 
// §[class.temporary]¶4 in the standard:
// "Temporary objects are destroyed as the last step in evaluating the full-expression (§4.k) that (lexically)
// contains the point where they were created."



// REF 1: f() const
// https://stackoverflow.com/questions/15999123/const-before-parameter-vs-const-after-function-name-c
//
// struct X
// {
//     void foo() const // <== The implicit "this" pointer is const-qualified!
//     {
//         _x = 42; // ERROR! The "this" pointer is implicitly const
//         _y = 42; // OK (_y is mutable)
//     }
// 
//     void bar(X& obj) const // <== The implicit "this" pointer is const-qualified!
//     {
//         obj._x = 42; // OK! obj is a reference to non-const
//         _x = 42; // ERROR! The "this" pointer is implicitly const
//     }
// 
//     void bar(X const& obj) // <== The implicit "this" pointer is NOT const-qualified!
//     {
//         obj._x = 42; // ERROR! obj is a reference to const
//         obj._y = 42; // OK! obj is a reference to const, but _y is mutable
//         _x = 42; // OK! The "this" pointer is implicitly non-const
//     }
// 
//     int _x;
//     mutable int _y;
// };
