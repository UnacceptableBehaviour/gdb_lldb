// compile with - C++17
//
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// -v 		    verbose show commands issued by compiler / linker
// -Wall 	    show c++ related warnnings
// -Weff++ 	  warning generated by code that breaks coding advice in Effective C++ - S.Meyers   
// -g  		    include debugger information
// -std=c++17 __cplusplus=201703 => C++ Standard=C++17

// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thread, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


//#include<cassert>
//#include<iostream>
//using namespace std;
//
//#include"interface_demo.h"
//
//
//unsigned int read_io_pin_00 (void) {
//	volatile int port_pins = 0x50;		// simulate a port read
//										
//	return port_pins & 0x01;	
//}
//
//// call_stack(5) to create a 5 frame call stack
//// set BP on new_depths = 0xFF0
//int call_stack(int deep, int how_deep = 0){
//	
//	volatile long int new_depths = 0xFF << how_deep;
//	
//	cout << new_depths << endl;
//	
//	if (how_deep <= deep)
//		call_stack(deep, how_deep+1);
//	
//	return 0; 
//}

// std::cout << a << b << '\n';
// std::cout << n << ", " << n << ", " << n << ", " << n << ", " << " \n";
#include <iostream>
//#include <string>
//#include <algorithm>  // std::find, std::for_each

void p(int v, std::string msg=""){
    std::cout << msg << ": " << v << " \n";  
}

//#include <vector>
//void pv(std::vector<int> v, std::string msg=""){
//    std::cout << msg << ": " << "v = { ";
//    for (int n : v) {
//        std::cout << n << " ";
//    }
//    std::cout << "}; \n";  
//}

// https://cppquiz.org/
// q160.cc

//struct A {
//    virtual void foo (int a = 1) {
//        std::cout << "A" << a;
//    }
//};
//
//struct B : A {                      // struct B : public A {
//    virtual void foo (int a = 2) {
//        std::cout << "B" << a;
//    }
//};
//
//int main () {
//    A *b = new B;       // Definition or var b type A* pointer to type B
//                        // new B no o/p: calls ctor A, ctor B
//    // static type A determines the DEFAULT values          a=1
//    // dynamic type B determines which function is called   B::foo()
//    b->foo();           // (*A)->B::foo(A::a=1)  B1
//    
//    std::cout << "\n";
//
//    B *bb = new B;      // Definition or var bb type B* pointer to type B
//                        // new B no o/p: calls ctor A, ctor B
//    bb->foo();          // (B)->foo()  B2
//    
//    std::cout << "\n";    
//}

// initial guess type B calls B::foo() with default a value 2
// B2
// Actual: B1

// In the first line of main, we create a new B object, with an A pointer b pointing to it.
// 
// On the next line, we call b->foo(), where b has the static type A, and the dynamic type B.
// Since foo() is virtual, the dynamic type of b is used to ensure B::foo() gets called rather than A::foo().
// 
// However, which default argument is used for the int a parameter to foo()?
// 
// §[dcl.fct.default]¶10 in the standard:
// A virtual function call (§ 13.3) uses the default arguments in the declaration of the virtual function
// determined by the STATIC TYPE OF THE POINTER OR REFERENCE denoting the object. An overriding function
// in a derived class does not acquire default arguments from the function it overrides.
// 
// So B::foo() is called, but with the default argument from A::foo(), and the output is B1.




// This compiles with 2 warnings (the same):
// test_c++.cc:110:8: warning: 'A' has virtual functions but non-virtual destructor [-Wnon-virtual-dtor]
// struct A {
//        ^
// test_c++.cc:116:8: warning: 'B' has virtual functions but non-virtual destructor [-Wnon-virtual-dtor]
// struct B : A {
//        ^
//        
// Why do we Need VIRTUAL DESTRUCTORS?
// https://www.linkedin.com/pulse/why-do-we-need-virtual-destructors-joydip-kanjilal#:~:text=Virtual%20destructors%20in%20C%2B%2B%20are,databases%20or%20other%20external%20objects.
// Virtual destructors in C++ are used to avoid memory leaks especially when your class contains unmanaged
// code, i.e., contains pointers or object handles to files, databases or other external objects.
// See notes at bottom

struct A {
    virtual void foo (int a = 1) {
        std::cout << "A" << a << std::endl;
    }
    //virtual ~A(){std::cout << "dtor A" << std::endl;}
    //virtual ~A() = 0; // Undefined symbols: "A::~A()", referenced from: B::~B() in test_c++-0bde9d.o  LINKER ERROR: ld: symbol(s) not found for architecture x86_64
};

struct B : A {                      // struct B : public A {
    virtual void foo (int a = 2) {
        std::cout << "B" << a << std::endl;
    }
    virtual void foo (char a) {
        std::cout << "C" << a << std::endl;
    }
    ~B(){std::cout << "dtor B" << std::endl;}
};

int main () {
    A *ab = new B;       // Definition or var b type A* pointer to type B
                        // new B no o/p: calls ctor A, ctor B
    // static type A determines the default values          a=1
    // dynamic type B determines which function is called   B::foo()
    ab->foo();           // B1
    // static type A determines the default values          a=3    doesnt use DEFAULT parameter passed = 3
    ab->foo(3);          // B3
    
    std::cout << "\n";

    B *bb = new B;      // Definition or var bb type B* pointer to type B
                        // new B no o/p: calls ctor A, ctor B
    bb->foo();          // B2
    bb->foo(3);         // B3
    
    std::cout << "\n";    

    A *abb = new B;      // Definition or var b type A* pointer to type B
                        // new B no o/p: calls ctor A, ctor B
    // static type A determines the default values          a=3         doesnt use DEFAULT parameter passed
    // dynamic type B determines which function is called   B::foo()
    abb->foo();           // B1
    
    std::cout << "\n";

    B *bbb = new B;      // Definition or var bb type B* pointer to type B
                         // new B no o/p: calls ctor A, ctor B
    bbb->foo('T');       // CT
    
    std::cout << "\n";
    
    std::cout << "del ab\n";
    delete(ab);
    std::cout << "del bb\n";
    delete(bb);
    std::cout << "del abb\n";
    delete(abb);
    std::cout << "del bbb\n";
    delete(bbb);
}

// VIRTUAL DE$STRUCTORS
// With line 174 commented IN: virtual destructor included in base class
// both A and B dtors are called
// B1
// B3
// 
// B2
// B3
// 
// B1
// 
// CT
// 
// del ab
// dtor B
// dtor A
// del bb
// dtor B
// dtor A
// del abb
// dtor B
// dtor A
// del bbb
// dtor B
// dtor A
   
// With line 174 commented OUT: NO virtual destructor included in base class
// generates WARNINGS but compiles
// the dtor for B only called if poiter to object is type *B
// B1
// B3
// 
// B2
// B3
// 
// B1
// 
// CT
// 
// del ab
// del bb
// dtor B
// del abb
// del bbb
// dtor B
   
// Default dtor for A called (no output), but dctor for B only called when pointer is type B*
   
//  COMPILES with WARNINGS
// test_c++.cc:171:8: warning: 'A' has virtual functions but non-virtual destructor [-Wnon-virtual-dtor]
// struct A {
//        ^
// test_c++.cc:186:5: warning: 'B' has virtual functions but non-virtual destructor [-Wnon-virtual-dtor]
//     ~B(){std::cout << "dtor B" << std::endl;}
//     ^
// test_c++.cc:222:5: warning: delete called on non-final 'A' that has virtual functions but non-virtual destructor
//       [-Wdelete-non-abstract-non-virtual-dtor]
//     delete(ab);
//     ^
// test_c++.cc:224:5: warning: delete called on non-final 'B' that has virtual functions but non-virtual destructor
//       [-Wdelete-non-abstract-non-virtual-dtor]
//     delete(bb);
//     ^
// test_c++.cc:226:5: warning: delete called on non-final 'A' that has virtual functions but non-virtual destructor
//       [-Wdelete-non-abstract-non-virtual-dtor]
//     delete(abb);
//     ^
// test_c++.cc:228:5: warning: delete called on non-final 'B' that has virtual functions but non-virtual destructor
//       [-Wdelete-non-abstract-non-virtual-dtor]
//     delete(bbb);
//     ^
// 6 warnings generated.
