// compile with - C++17
//
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// -v 		    verbose show commands issued by compiler / linker
// -Wall 	    show c++ related warnnings
// -Weff++ 	  warning generated by code that breaks coding advice in Effective C++ - S.Meyers   
// -g  		    include debugger information
// -std=c++17 __cplusplus=201703 => C++ Standard=C++17

// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thread, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


//#include<cassert>
//#include<iostream>
//using namespace std;
//
//#include"interface_demo.h"
//
//
//unsigned int read_io_pin_00 (void) {
//	volatile int port_pins = 0x50;		// simulate a port read
//										
//	return port_pins & 0x01;	
//}
//
//// call_stack(5) to create a 5 frame call stack
//// set BP on new_depths = 0xFF0
//int call_stack(int deep, int how_deep = 0){
//	
//	volatile long int new_depths = 0xFF << how_deep;
//	
//	cout << new_depths << endl;
//	
//	if (how_deep <= deep)
//		call_stack(deep, how_deep+1);
//	
//	return 0; 
//}

// std::cout << a << b << '\n';
// std::cout << n << ", " << n << ", " << n << ", " << n << ", " << " \n";
#include <iostream>
//#include <string>
//#include <algorithm>  // std::find, std::for_each

void p(int v, std::string msg=""){
    std::cout << msg << ": " << v << " \n";  
}

//#include <vector>
//void pv(std::vector<int> v, std::string msg=""){
//    std::cout << msg << ": " << "v = { ";
//    for (int n : v) {
//        std::cout << n << " ";
//    }
//    std::cout << "}; \n";  
//}

// q279.cc
                        // https://en.cppreference.com/w/cpp/utility/variant
#include <variant>      // template for unions
                        // not permitted to hold references, arrays, or the type void
                        // Empty variants are ill-formed (use std::variant<std::monostate>)

struct C                // members public by default
{
    C() : i(1){ p(i,"ctor C"); } // ctor w/ initialiser list, initialises i=1
    int i;
};

struct D
{
    D() : i(2){ p(i,"ctor D"); }
    int i;
};

struct E
{
    E() : i(3){ p(i,"ctor E"); }
    int i;
};

void p(struct C v, std::string msg=""){
    std::cout << msg << ": " << v.i << " \n";  
}
void p(struct E v, std::string msg=""){
    std::cout << msg << ": " << v.i << " \n";  
}
//// error: no member named 'i' in 'std::__1::variant<E, D, C>'
//void p(const std::variant<E, D,C> v, std::string msg=""){
//    std::cout << msg << ": " << v.i << " \n";  
//}
//
//// error: 'auto' not allowed in function prototype  - NOTE OK in lambda expression!
//void p(auto&& v, std::string msg=""){
//    std::cout << msg << ": " << v.i << " \n";  
//}


int main()
{
    C sc;
    p( sc.i, "sc.i");
  
    p( 99, "const std::variant<C,D> v");
    const std::variant<C,D> v;  // declare variant v, call ctor C only
    
    p( 99, "const std::variant<D,C> w");
    const std::variant<D,C> w;  // declare variant v, call ctor D only

    p( 99, "const std::variant<E,D,C> x");
    const std::variant<E, D,C> x;  // declare variant v, call ctor E only
    
    //p(std::get<C>(x), "std::get<C>(x)");  // terminating with uncaught exception of type std::bad_variant_access: bad_variant_access
                                            // variant currently contains type E 
    p(std::get<E>(x), "std::get<E>(x)");    // std::get<E>(x): 3


    // template <class R, class Visitor, class... Variants>
    // constexpr R visit( Visitor&& vis, Variants&&... vars );
    //
    // vis	-	a Callable that accepts every possible alternative from every variant
    // vars	-	list of variants to pass to the visitor
    //std::visit(
    //            [](const auto& val){ std::cout << val.i; }, // vis
    //            v                                           // vars
    //          );

    std::visit([](const auto& val){ std::cout << val.i; }, v);  // v conatins object type C who's i=1
}

// https://stackoverflow.com/questions/4686507/lambda-expression-vs-functor-in-c
// lambda expression creates an nameless functor, it's syntactic sugar
// [](const auto& val){ std::cout << val.i; }

// functor - see q114_vector.cc ln 195
// https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses

// auto&&  // https://stackoverflow.com/questions/13230480/what-does-auto-tell-us

// auto&&  vs   const auto&
// A "universal reference", auto&& or T&&, will bind to anything.
// https://stackoverflow.com/questions/13230480/what-does-auto-tell-us
// You might say, well why not just use a const auto& because that will also bind to anything?
// The problem with using a const reference is that it's const!
// You won't be able to later bind it to any non-const references or invoke any member functions
// that are not marked const.
//
// more on Universal Refs - Scott Myers TODO
// https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers


// what the const

// #include <variant>
// https://riptutorial.com/cplusplus/example/18604/basic-std--variant-use
//std::variant< int, std::string > var;
//
//var = "hello"s;
//
//// Prints "hello\n":
//visit( [](auto&& e) {       // auto&&  I will accept any initializer regardless of whether it is an lvalue or rvalue expression and I will preserve its constness
//  std::cout << e << '\n';
//}, var );




