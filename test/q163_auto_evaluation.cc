// compile with - C++17
//
// g++ -v -Wall -Weffc++ -std=c++17 test_c++.cc -o test_c++
// -v 		    verbose show commands issued by compiler / linker
// -Wall 	    show c++ related warnnings
// -Weff++ 	  warning generated by code that breaks coding advice in Effective C++ - S.Meyers   
// -g  		    include debugger information
// -std=c++17 __cplusplus=201703 => C++ Standard=C++17

// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thread, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


//#include<cassert>
//#include<iostream>
//using namespace std;
//
//#include"interface_demo.h"
//
//
//unsigned int read_io_pin_00 (void) {
//	volatile int port_pins = 0x50;		// simulate a port read
//										
//	return port_pins & 0x01;	
//}
//
//// call_stack(5) to create a 5 frame call stack
//// set BP on new_depths = 0xFF0
//int call_stack(int deep, int how_deep = 0){
//	
//	volatile long int new_depths = 0xFF << how_deep;
//	
//	cout << new_depths << endl;
//	
//	if (how_deep <= deep)
//		call_stack(deep, how_deep+1);
//	
//	return 0; 
//}

// std::cout << a << b << '\n'; 
#include <iostream>

// q163.cc
class A {
  int foo = 0;

public:  
  int& getFoo() { return foo; }
  void printFoo() { std::cout << foo; }

  //int& getFoo() { return &foo; }
  // error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int *'
};

int main() {
  A a;

  //auto bar = a.getFoo();      // auto evaluates to int not int&
                                // o/p 10
  int& bar = a.getFoo();        // setting type to int& - we get expected behaviour
                                // o/p 11
  
  ++bar;
  std::cout << bar << '\n';     // 1
  
  a.printFoo();                 // 0
}


// To get to the bottom of this, we need to take a detour via function templates.
// 
// According to §[dcl.spec.auto]¶6 (auto specifier) in the standard:
// "The type of each declared variable is determined by placeholder type deduction (§10.1.7.4.1)."
// 
// Placeholder type deduction works as per §[dcl.type.auto.deduct]¶4 :
// 
// If the placeholder is the auto type-specifier, the deduced type T' replacing T is determined
// using the rules for template argument deduction. (...) Deduce a value for U [the template
// parameter for the invented function] using the rules of template argument deduction from a
// function call (§17.8.2.1) (...).
// 
// So the rules for auto bar = a.getFoo(); are the same as if we did
// 
// template<typename T> void f(T t);
// f(a.getFoo());
// 
// Let's have a look at §[temp.deduct.call]¶4:
// "In general, the deduction process attempts to find template argument values that will make the
// deduced A identical to A" (where A is the type of the argument of the call.)
// 
// Now what is the type of the argument of the call? getFoo() returns int&, but let's see what
// §[expr]¶5 has to say about the type of expressions:
// "If an expression initially has the type “reference to T”, the type is adjusted to T prior to any
// further analysis."
// 
// So the type of the expression a.getFoo() that is used for deduction is int, not int&.
// Now int is being used for deducing T in our imaginary void f(T t), so T is int.
// Since auto uses the same rule, the type of bar is also int.
// 
// Since bar is not a reference, incrementing it does not increment foo, and the output of
// the program is 0.
