// compile with g++ -v -Wall -Weffc++ null_ref.cc interface_demo.cc -o null_ref
// -v 		verbose show commands issued by compiler / linker
// -Wall 	show c++ related warnnings
// -Weff++ 	warning generated by code that breaks coding advice in Effective C++ - S.Meyers
// -g  		include debugger information
//
// GDB-LLDB command map - https://lldb.llvm.org/use/map.html
// Intro LLDB - https://towardsdatascience.com/an-introduction-to-debugging-in-c-and-lldb-part-i-e3c51991f83a
// LLDB command format - <noun> <verb> [-options [option-value]] [argument [argument...]]
//						  |		  |
//	target (thead, frame etc)	  |
//							   command
//
// (lldb) breakpoint set -l 39					# set BP at line 39
// (lldb) settings show target.run-args			# show args passed in to start
// target.run-args (array of strings) =
//   [0]: "turkey"
//   [1]: "cruffins"
// (lldb) thread step-in 						# step in
// (lldb) step 
// (lldb) s
// (lldb) thread step-over 						# step over
// (lldb) next 
// (lldb) n 
// (lldb) thread step-out 						# step out of current frame
// (lldb) finish 
// (lldb) breakpoint set --name main 			# set BP function main
// (lldb) br s -n main 
// (lldb) b main
// (lldb) breakpoint list 						# list BPs
// (lldb) br l
// (lldb) breakpoint delete 1 					# del BP
// (lldb) br del 1
// 												# set BP in FILE at LINE no.
// (lldb) breakpoint set --file test.c --line 12 		
// (lldb) br s -f test.c -l 12 
// (lldb) b test.c:12
// 												# conditional BP
// (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0' 
// (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'
											

// quick note about python2 - err WTF? yep . .
// https://www.legendiary.at/2016/11/27/lldb-nameerror-name-run_one_line-is-not-defined/
// and a fix: https://github.com/Homebrew/homebrew-core/issues/2730
// quick answer its a python dependency issue
// easy fix: $ python3 -m venv venv											# create clean environment
//           $ . venv/bin/activate											# activate it
//           $ g++ -v -Wall -Weffc++ -g null_ref.cc interface_demo.cc -o null_ref	# compile c++
//           $ lldb null_ref turkey cruffins								# fire up debugger w/ args
//           (lldb) run 													# execute
//           Process 29761 launched: '/Users/simon/a_syllabus/lang/c++/
//           compile_hello_world_refs_pointers/null_ref' (x86_64)


#include<cassert>
#include<iostream>
using namespace std;

#include"interface_demo.h"


unsigned int read_io_pin_00 (void) {
	volatile int port_pins = 0x50;		// simulate a port read
										
	return port_pins & 0x01;	
}

// call_stack(5) to create a 5 frame call stack
// set BP on new_depths = 0xFF0
int call_stack(int deep, int how_deep = 0){
	
	volatile long int new_depths = 0xFF << how_deep;
	
	cout << new_depths << endl;
	
	if (how_deep <= deep)
		call_stack(deep, how_deep+1);
	
	return 0; 
}

int main(int argc, char* argv[]) {
	
	// int &n = *(int*)0;	// compiler check
							// warning: binding dereferenced null pointer to reference has undefined behavior [-Wnull-dereference]
	
	int a = 30;
	int &x = a;

	cout << "Re-Hello World\n";
	cout << a << "\n" << endl;
	cout << x << "\n" << endl;
	cout << "Num args:" << argc << "\n" << endl;
	for (int i=0; i < argc; i++) {
		cout << argv[i] << "\n" << endl;	
	}
	
	assert( a == x );
	//assert( a != x ); // demo a fail
	
	cout << "Number of Observers = " << InterfaceDemo::GetNoOfClassObservers() << endl;
	assert( InterfaceDemo::GetNoOfClassObservers() == 0 );
	
	cout << "PIN 00: " << 0x00 << " <" << endl;
	
	cout << "PIN 00: " <<  read_io_pin_00() << " <" << endl;
	
	call_stack(5);

	cout << "Over and out . .\n" << endl;
	
	return 0;
}

//  - - - Example from code above
// $ lldb null_ref turkey cruffins
// (lldb) target create "null_ref"
// Current executable set to 'null_ref' (x86_64).
// (lldb) settings set -- target.run-args  "turkey" "cruffins"
// 
// --# set break point at apex of recursive call
// (lldb) breakpoint set --file null_ref.cc --line 78
// Breakpoint 1: where = null_ref`call_stack(int, int) + 64 at null_ref.cc:78, address = 0x0000000100000b70
// 
// --# run the code
// (lldb) run
// Process 30002 launched: '/lang/c++/compile_hello_world_refs_pointers/null_ref' (x86_64)
// Re-Hello World
// 30
//
// 30
// 
// Num args:3
// 
// /Users/simon/a_syllabus/lang/c++/compile_hello_world_refs_pointers/null_ref
// 
// turkey
// 
// cruffins
// 
// Number of Observers = 0
// PIN 00: 0 <
// PIN 00: 0 <
// Process 30002 stopped
// * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
//     frame #0: 0x0000000100000b70 null_ref`call_stack(deep=5, how_deep=6) at null_ref.cc:78
//    75  		if (how_deep <= deep)
//    76  			call_stack(deep, how_deep+1);
//    77  		
// -> 78  		return 0; 				# line 80 after cout added		< BP
//    79  	}
//    80  	
//    81  	int main(int argc, char* argv[]) {
// Target 0: (null_ref) stopped.
// (lldb) 
// (lldb) thread backtrace -c 9
// * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
//   * frame #0: 0x0000000100000b70 null_ref`call_stack(deep=5, how_deep=6) at null_ref.cc:78
//     frame #1: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=5) at null_ref.cc:76
//     frame #2: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=4) at null_ref.cc:76
//     frame #3: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=3) at null_ref.cc:76
//     frame #4: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=2) at null_ref.cc:76
//     frame #5: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=1) at null_ref.cc:76
//     frame #6: 0x0000000100000b6b null_ref`call_stack(deep=5, how_deep=0) at null_ref.cc:76
//     frame #7: 0x0000000100000e9f null_ref`main(argc=3, argv=0x00007fff5fbff490) at null_ref.cc:107
//     frame #8: 0x00007fffd5d52235 libdyld.dylib`start + 1
   
   
   